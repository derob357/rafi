#!/usr/bin/env python3
"""Generate DEPENDENCIES.md from requirements.txt.

Reads the project's requirements.txt file and produces a Markdown
table listing each package, its pinned version, and its purpose
in the project.

Usage:
    python scripts/generate_deps.py

Output:
    Writes DEPENDENCIES.md in the project root directory.
"""

from __future__ import annotations

import re
import sys
from pathlib import Path

# Map package names to their purpose in rafi_deploy
PACKAGE_PURPOSES: dict[str, str] = {
    "deepgram-sdk": "Speech-to-text transcription of onboarding interviews",
    "openai": "LLM API client for config extraction from transcripts",
    "twilio": "Twilio REST API client for phone number provisioning",
    "supabase": "Supabase client library (used for health checks and validation)",
    "httpx": "Async HTTP client for Supabase Management API calls",
    "pyyaml": "YAML parsing and serialization for client config files",
    "pydantic": "Data validation and settings management for config schemas",
    "paramiko": "SSH client for managing Docker containers on EC2",
    "sounddevice": "Audio recording from microphone for onboarding interviews",
    "soundfile": "WAV file reading and writing for recorded interviews",
    "python-json-logger": "Structured JSON log formatting",
    "pytest": "Testing framework",
    "pytest-asyncio": "Async test support for pytest",
    "pytest-cov": "Code coverage reporting for pytest",
    "pytest-mock": "Mock fixtures and utilities for pytest",
}


def parse_requirements(requirements_path: Path) -> list[tuple[str, str]]:
    """Parse requirements.txt and extract package names and versions.

    Args:
        requirements_path: Path to the requirements.txt file.

    Returns:
        List of (package_name, version) tuples.
    """
    if not requirements_path.exists():
        print(f"Error: {requirements_path} not found", file=sys.stderr)
        sys.exit(1)

    packages: list[tuple[str, str]] = []
    content = requirements_path.read_text(encoding="utf-8")

    for line in content.splitlines():
        line = line.strip()

        # Skip empty lines and comments
        if not line or line.startswith("#") or line.startswith("-"):
            continue

        # Parse package==version, package>=version, package~=version, etc.
        match = re.match(r"^([a-zA-Z0-9_\-]+)\s*[=~><!]+\s*(.+)$", line)
        if match:
            name = match.group(1).strip()
            version = match.group(2).strip()
            packages.append((name, version))
        elif re.match(r"^[a-zA-Z0-9_\-]+$", line):
            # Package with no version pin
            packages.append((line, "latest"))

    return packages


def generate_markdown(packages: list[tuple[str, str]]) -> str:
    """Generate the DEPENDENCIES.md content.

    Args:
        packages: List of (package_name, version) tuples.

    Returns:
        The Markdown content string.
    """
    lines = [
        "# Dependencies",
        "",
        "Auto-generated by `python scripts/generate_deps.py`.",
        "Do not edit manually -- regenerate after any dependency changes.",
        "",
        "| Package | Version | Purpose |",
        "|---------|---------|---------|",
    ]

    for name, version in packages:
        purpose = PACKAGE_PURPOSES.get(name, "")
        if not purpose:
            # Try lowercase lookup
            purpose = PACKAGE_PURPOSES.get(name.lower(), "Third-party dependency")
        lines.append(f"| {name} | {version} | {purpose} |")

    lines.append("")
    return "\n".join(lines)


def main() -> None:
    """Main entry point."""
    # Determine project root (parent of scripts/)
    script_dir = Path(__file__).resolve().parent
    project_root = script_dir.parent

    requirements_path = project_root / "requirements.txt"
    output_path = project_root / "DEPENDENCIES.md"

    print(f"Reading: {requirements_path}")
    packages = parse_requirements(requirements_path)

    if not packages:
        print("Warning: No packages found in requirements.txt", file=sys.stderr)
        sys.exit(1)

    print(f"Found {len(packages)} packages")

    markdown = generate_markdown(packages)
    output_path.write_text(markdown, encoding="utf-8")

    print(f"Generated: {output_path}")
    print("Done.")


if __name__ == "__main__":
    main()
